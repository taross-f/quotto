import sharp from 'sharp';
import * as fs from 'node:fs';
import * as path from 'node:path';

export interface QuoteData {
  quote: string;
  title?: string;
  author?: string;
}

const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 800;
const MARGIN = 60;
const MAX_TEXT_WIDTH = CANVAS_WIDTH - (MARGIN * 2);

function wrapText(text: string, maxWidth: number, fontSize: number): string[] {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';
  
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const estimatedWidth = testLine.length * (fontSize * 0.6);
    
    if (estimatedWidth > maxWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
}

function escapeXml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

export async function generateKindleQuoteImage(
  quoteData: QuoteData,
  outputPath: string
): Promise<void> {
  if (!quoteData.quote || quoteData.quote.trim() === '') {
    throw new Error('Quote text cannot be empty');
  }

  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const quoteFontSize = 24;
  const titleFontSize = 18;
  const authorFontSize = 16;
  
  const quoteLines = wrapText(quoteData.quote, MAX_TEXT_WIDTH, quoteFontSize);
  
  let currentY = 120;
  
  let quoteElements = '';
  for (const line of quoteLines) {
    quoteElements += `<text x="${CANVAS_WIDTH / 2}" y="${currentY}" fill="#2c3e50" font-size="${quoteFontSize}" font-family="Georgia, serif" text-anchor="middle" font-style="italic">${escapeXml(line)}</text>`;
    currentY += quoteFontSize + 8;
  }
  
  currentY += 40;
  
  let titleElement = '';
  if (quoteData.title) {
    const titleLines = wrapText(quoteData.title, MAX_TEXT_WIDTH, titleFontSize);
    for (const line of titleLines) {
      titleElement += `<text x="${CANVAS_WIDTH / 2}" y="${currentY}" fill="#34495e" font-size="${titleFontSize}" font-family="Georgia, serif" text-anchor="middle" font-weight="bold">${escapeXml(line)}</text>`;
      currentY += titleFontSize + 6;
    }
    currentY += 20;
  }
  
  let authorElement = '';
  if (quoteData.author) {
    const authorLines = wrapText(quoteData.author, MAX_TEXT_WIDTH, authorFontSize);
    for (const line of authorLines) {
      authorElement += `<text x="${CANVAS_WIDTH / 2}" y="${currentY}" fill="#7f8c8d" font-size="${authorFontSize}" font-family="Georgia, serif" text-anchor="middle">${escapeXml(line)}</text>`;
      currentY += authorFontSize + 4;
    }
  }

  const svg = `
    <svg width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#f8f9fa"/>
      <rect x="0" y="0" width="100%" height="8" fill="#3498db"/>
      <rect x="0" y="${CANVAS_HEIGHT - 8}" width="100%" height="8" fill="#3498db"/>
      
      <text x="${CANVAS_WIDTH / 2}" y="60" fill="#2c3e50" font-size="14" font-family="Arial, sans-serif" text-anchor="middle" opacity="0.6">INNYO</text>
      
      <rect x="${MARGIN}" y="90" width="${MAX_TEXT_WIDTH}" height="2" fill="#ecf0f1"/>
      
      ${quoteElements}
      
      <rect x="${MARGIN}" y="${currentY - 20}" width="${MAX_TEXT_WIDTH}" height="1" fill="#ecf0f1"/>
      
      ${titleElement}
      ${authorElement}
      
      <text x="${CANVAS_WIDTH / 2}" y="${CANVAS_HEIGHT - 30}" fill="#95a5a6" font-size="12" font-family="Arial, sans-serif" text-anchor="middle" opacity="0.7">Generated by Innyo</text>
    </svg>
  `;

  const buffer = Buffer.from(svg);
  
  await sharp(buffer)
    .png()
    .toFile(outputPath);
}